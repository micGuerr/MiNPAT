function [eddy_outp, status] = runEddy(dwiData, topup, mask, acqp_file, baseName, parall)
% 
% Runs FSL's Eddy
%
% Usage:
%  [eddy_outp, status] = runEddy(dwiData, topup, mask, parall)
% 
% Input
%   dwiData     structure.
%   topup       Output of topup step.
%   mask        path to brain mask
%   parall      number of cores to be used for paralle computing. Leave
%               empty if no parallelization is requred.
% 
% Output:
%   eddy_outp   structure in which are stored the paths to topup outputs.
%   status      numeric value describing the status of the executed system
%               command.
% 
% Author:
%   Michele Guerreri (m.guerreri@ucl.ac.uk)

%% First thing, let's parse the DWI acquisition information. 
%  Let's check everything needed is there.

acqs = fieldnames(dwiData);
n_acqs = length(acqs);

% The fields "vol", "bval", "bvec", "sc" are expected for each acquisition
for ii = 1 : n_acqs
    In = dwiData.(acqs{ii}); % make things easier to read
    if ~isfield(In, 'vol') || ...
            ~isfield(In, 'bval') || ...
            ~isfield(In, 'bvec') || ...
            ~isfield(In, 'sc')
        error('''vol'', ''bval'', ''bvec'' or ''sc'', missing in acquisition %s !!', ...
            acqs{ii} );
    end
end

% Let's make sure that topup run
if ~exist( [topup, '_fieldcoef.nii.gz'], 'file')
    error('Output from topup seems to be missing');
end

% Let's make sure that bet run
if ~exist( mask, 'file')
    error('Output from bet seems to be missing');
end

%% Next, check the output folder exists. If not create it

% extract topup folder from the baseName
[eddyDir, eddyBname] = fileparts(baseName);

if ~exist(eddyDir, 'dir')
    mkdir(eddyDir);
end


%% Let's now merge all the diffusion volumes together.
% We also need to merge the b-values and bvecs.

% the output being
all_dwis_path = sprintf(eddyDir, 'allDwis.nii.gz');
all_bval_path = sprintf(eddyDir, 'allBval.bval');
all_bvec_path = sprintf(eddyDir, 'allBvec.bvec');
% temporary variable for dwi volumes tracking
tmp_dwi = [];

if ~exist(all_dwis_path, 'file')
    In = dwiData.(acqs{ii}); % make things easier to read
    % open b-val and b-vecs files
    % define tmp variables
    bval = [];
    bvec = [];
    % Loop over the acquisitions
    for ii = 1 : n_acqs
        tmp_dwi = [tmp_dwi ' ' In.vol ];
        tmp_bval = load_bVal(In.bval);
        bval = cat(2, bval, tmp_bval);
        tmp_bvec = importdata(In.bvec);
        bvec = cat(2, bvec, tmp_bvec);
    end
    % Run the merging command
    mrg_cmd = sptintf('fslmerge -t %s %s', all_dwis_path, tmp_dwi);
    mrg_status = runSystemCmd(mrg_cmd, 1);
    % Get the bval/bvec files
    mk_bvalFile(bval, all_bval_path);
    mk_bvecFile(bvec, all_bvec_path);
else
    warning('File %s already exist, DWIs stacks NOT merged.', all_dwis_path);
end

%% Now let's define the idx file. This should have an index correpsonding 
% to the line ...

% define the output indices file
idx_path = fullfile(eddyDir, 'inidices.txt');


getEddyIdxFile()

% load the dwis and check how many volumes are there
all_dwis = load_untouch_nii(all_dwis_path);
n_dwis = all_dwis.hdr.dime.dim(5);
% load the all-bvalues file
all_bvals = load_bVal(all_bval_path);


if ~exist(idx_path, 'file')
    % Check if there is a mismatch between all_dwis number and all b-values
    if n_dwis ~= length(all_bvals)
        error('mismatch between number of volumes in %s and b-values in %s', ...
           all_dwis_path,  all_bval_path);
    end
    % open the file
    fid = fopen(idx_path, 'w+');
    tmp_idx = 0;
    % loop over the dwi volumes
    for ii = 1: n_dwis
        if all_bvals(ii) == 0
            tmp_idx = tmp_idx+1;
        end
        fprintf(idx_path, '%d\n', tmp_idx);
    end
    fclose(fid);
else
    warning('File %s already exist, idx_path not overwritten.', idx_path);
end



%% Run Eddy
